\section{Problema 3}

\subsection{Definizione dei sottoproblemi}

Nella risoluzione del problema, abbiamo focalizzato il nostro ragionamento sulla proprietà fondamentale che deve avere un albero per
essere accettabile, ovvero:
\begin{itemize}
    \item Il costo complessivo dell'albero deve essere minimo.
    \item Ogni nodo interno deve avere esattamente due figli.
    \item L'albero ha  esattamente $n$ foglie.
\end{itemize}

\begin{center}
    \textbf{$OPT[i, j]$ rappresenta l'albero di costo minimo contenente le foglie $\{C[j], C[j + 1], ..., C[j + i - 1]\}$ date in input, 
    $\forall i\ \in\ \{1, ..., n\} \land \forall j\ \in\ \{1, ..., n - i + 1\}$ dove $i$ indica la $i-esima$ riga e $j$ indica la $j-esima$ colonna della matrice $OPT$.}
\end{center}

\subsection{Struttura dati}

Abbiamo definito una matrice $OPT$ di dimensioni $n \times n$, dove ogni cella contiene 4 valori:

\begin{itemize}
  \item $OPT[i, j].val$: il costo minimo per costruire un albero con le foglie che vanno da $j$ a $j + i - 1$ (dove $i$ rappresenta le righe e $j$ le colonne).
  \item $OPT[i, j].max$: il valore massimo tra le foglie all'interno dell'intervallo $[j: j + i - 1]$.
  \item $OPT[i, j].sin$: le coppie di indici $i,\ j$ che all'interno di $OPT$ ci indicano quale cella guardare per ricostruire la struttura del sottoalbero sinistro.
  \item $OPT[i, j].des$: le coppie di indici $i,\ j$ che all'interno di $OPT$ ci indicano quale cella guardare per ricostruire la struttura del sottoalbero destro.
\end{itemize}

Tuttavia, è importante notare che utilizziamo solo la metà delle celle di $OPT$. In particolare,
ci limitiamo alla matrice triangolare superiore sinistra, poiché oltre questa 
zona andremmo oltre il numero di foglie salvate nell'array $C$, che contiene i valori delle foglie dati in input.

\subsection{Combinazione dei sottoproblemi}

Nel processo di combinazione dei sottoproblemi, abbiamo tenuto presente che un albero ottimale deve essere strutturato in modo binario, cioè deve avere due 
sottoalberi per ogni nodo interno. Questa considerazione ci ha portato a distinguere le foglie in due gruppi: le "foglie destre", che appartengono al sottoalbero 
destro, e le "foglie sinistre", che appartengono al sottoalbero sinistro.

\subsubsection*{Casi base}

Durante l'analisi dei casi base, abbiamo individuato due situazioni:

\begin{itemize}
  \item {
    Il primo caso base riguarda la prima riga della matrice, che rappresenta una foglia singola. In questo caso, assegniamo il valore della foglia a $OPT[1, j].max$, 
    mentre poniamo il valore di $OPT[1, j].val = 0$ (poiché per la nostra definizione le foglie non hanno valore). $OPT[1, j].sin$ e $OPT[1, j].des$ non vengono inizializzate in quanto 
    non ci sono sottoalberi.
  }
  \item {
    Il secondo caso base si riferisce alla seconda riga della matrice, che rappresenta un albero con solo due foglie. Questo albero può essere combinato in un 
    unico modo, poiché le foglie devono essere ordinate secondo una visita simmetrica rispetto all'input. In questo caso, il valore di $OPT[2, j].val$ è il prodotto tra 
    gli $OPT[1, j].max$ e $OPT[1, j + 1].max$ i quali indicano le foglie, mentre $OPT[2, j].max$ rappresenta il massimo tra i due valori delle foglie. Inoltre, assegniamo gli indici delle foglie a $OPT[2, j].sin$ e $OPT[2, j].des$ 
    per poter trovare facilmente le loro posizioni nella matrice.
  }
\end{itemize}

\subsubsection*{Caso generico}

Avendo effettuato questa suddivisione tra sottoalbero destro e sottoalbero sinistro, ci siamo resi conto che la chiave per trovare il valore dell'albero 
ottimale consiste nel provare tutte le possibili suddivisioni fra foglie destre e sinistre e trovare quella con il costo complessivo minimo. Questo si riduce a 
cercare un indice $k$ nell'intervallo $[1 : i - 1]$ tale che il nodo risultante dalla combinazione del sottoalbero sinistro contenente le foglie da $j$ a $j + k$ e del 
sottoalbero destro contenente le foglie da $j + k +1$ a $j + i - 1$ sia il più piccolo possibile in termini di costo.

\subsubsection*{Esempio}

Supponiamo di avere in input il seguente vettore $C = [4, 2, 7]$ con 3 foglie.

\[
\begin{bmatrix}
  a & c & d \\
  e & f & g \\
  h & l & m \\
\end{bmatrix}
\]

\begin{enumerate*}[label={}]
    \item {
  \begin{tikzpicture}[
      level/.style={sibling distance=40mm/#1},
      every node/.style={circle, draw, fill=black!10},
      level 1/.style={level distance=15mm},
      level 2/.style={level distance=12mm},
      level 3/.style={level distance=10mm}
    ]
    \node {28}
    child {node {4}}
    child {node {14}
        child {node {2}}
        child {node {7}}
    };
  \end{tikzpicture}
  }
  \newline
  \item{
    In questo caso il nostro $k = 1$ e di conseguenza, il costo totale dell'albero è 42
  }
\end{enumerate*}
\\
\\

\begin{enumerate*}[label={}]
  \item {
  \begin{tikzpicture}[
      level/.style={sibling distance=40mm/#1},
      every node/.style={circle, draw, fill=black!10},
      level 1/.style={level distance=15mm},
      level 2/.style={level distance=12mm},
      level 3/.style={level distance=10mm}
    ]
    \node {28}
    child {node {8}
        child {node {4}}
        child {node {2}}
      }
    child {node {7}};
  \end{tikzpicture}
  }
  \newline
  \item{
    In questo caso il nostro $k = 2$ e di conseguenza, il costo totale dell'albero è 36, che è minimo.
  }
\end{enumerate*}

\subsubsection*{Formula di Bellman}

\subsection{Pseudocodice}